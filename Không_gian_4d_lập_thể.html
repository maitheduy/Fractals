<!DOCTYPE html>
<html>
<head>
<title>4D Chaos Game Attractor (Phép chiếu Lập thể)</title>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<style>
  body { font-family: sans-serif; display: flex; height: 100vh; margin: 0; overflow: hidden; }
  #left-panel { width: 40%; padding: 20px; box-sizing: border-box; background-color: #2c3e50; color: #ecf0f1; overflow-y: auto; }
  #left-panel h2, #left-panel h3 { color: #ffffff; border-bottom: 1px solid #34495e; padding-bottom: 10px; margin-top: 20px; }
  #right-panel { width: 60%; position: relative; }
  canvas { display: block; }
  .axis-label { font-size: 16px; font-family: 'Courier New', Courier, monospace; font-weight: bold; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; }
  
  .control-group { margin-top: 15px; }
  .control-group label { font-weight: bold; }
  .control-group input[type="range"] { width: 100%; cursor: pointer; }

  #controls { display: flex; gap: 10px; margin-top: 15px; }
  .control-btn { flex-grow: 1; padding: 10px; font-size: 14px; cursor: pointer; background-color: #34495e; color: #ecf0f1; border: 1px solid #4a627a; border-radius: 4px; transition: background-color 0.2s; }
  .control-btn:hover { background-color: #4a627a; }
</style>
</head>
<body>

<div id="left-panel">
  <h2>Hàm co trong không gian 4D</h2>
  
  <!-- SLIDER MỚI CHO THAM SỐ S -->
  <div class="control-group">
      <label for="s-slider">Hệ số co s = <span id="s-value">0.95</span></label>
      <input type="range" id="s-slider" min="0.8" max="0.99" value="0.95" step="0.01">
  </div>

  <p>Hàm \(f_1\) (tạo ra mảnh màu xanh lá):</p>
  <div id="f1-equation">
    $$
    \mathbf{p}' = 0.95 \cdot \left( \begin{pmatrix} 0 & 0 & 0 & 1 \\ 1/2 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \end{pmatrix}
    \mathbf{p} \right)
    $$
  </div>
  <p>Hàm \(f_2\) (tạo ra mảnh màu đỏ):</p>
  <div id="f2-equation">
    $$
    \mathbf{p}' = 0.95 \cdot \left( \begin{pmatrix} 0 & 0 & 0 & 1 \\ 1/2 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \end{pmatrix}
    \mathbf{p} +
    \begin{pmatrix} 0 \\ 1/2 \\ 0 \\ 0 \end{pmatrix} \right)
    $$
  </div>

  <h3>Điều khiển Hiển thị</h3>
  <div id="controls">
    <button id="btn-green" class="control-btn">Chỉ mảnh Xanh</button>
    <button id="btn-red" class="control-btn">Chỉ mảnh Đỏ</button>
    <button id="btn-both" class="control-btn">Cả hai mảnh</button>
  </div>
  
  <h3>Phép chiếu Lập thể 4D xuống 3D</h3>
  <p>Điểm 4D `(x, y, z, w)` được chiếu thành điểm 3D `(x', y', z')`:</p>
  <p>$$x' = \frac{x}{1-w}, \quad y' = \frac{y}{1-w}, \quad z' = \frac{z}{1-w}$$</p>
  
  <h3>Tương tác</h3>
  <ul>
      <li><b>Xoay:</b> Giữ và kéo chuột trái.</li>
      <li><b>Thu phóng:</b> Lăn con lăn chuột.</li>
      <li><b>Di chuyển:</b> Giữ và kéo chuột phải.</li>
  </ul>
</div>

<div id="right-panel">
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

  const rightPanel = document.getElementById('right-panel');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  const camera = new THREE.PerspectiveCamera(75, rightPanel.offsetWidth / rightPanel.offsetHeight, 0.1, 1000);
  camera.position.set(1, 1, 1.5);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  const labelRenderer = new CSS2DRenderer();
  renderer.setSize(rightPanel.offsetWidth, rightPanel.offsetHeight);
  labelRenderer.setSize(rightPanel.offsetWidth, rightPanel.offsetHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0px';
  labelRenderer.domElement.style.pointerEvents = 'none';
  rightPanel.appendChild(renderer.domElement);
  rightPanel.appendChild(labelRenderer.domElement);
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  const gridHelper = new THREE.GridHelper(4, 40, 0x444444, 0x888888);
  gridHelper.rotation.x = Math.PI / 2;
  scene.add(gridHelper);
  const axisLength = 1.5;
  scene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), axisLength, 0xff0000));
  scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), axisLength, 0x00ff00));
  scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), axisLength, 0x0000ff));
  function createAxisLabel(text, color, position) {
    const div = document.createElement('div');
    div.className = 'axis-label'; div.textContent = text; div.style.color = color;
    const label = new CSS2DObject(div); label.position.copy(position);
    return label;
  }
  scene.add(createAxisLabel('X', '#ff4d4d', new THREE.Vector3(axisLength + 0.1, 0, 0)));
  scene.add(createAxisLabel('Y', '#4dff4d', new THREE.Vector3(0, axisLength + 0.1, 0)));
  scene.add(createAxisLabel('Z', '#4da6ff', new THREE.Vector3(0, 0, axisLength + 0.1)));
  scene.add(createAxisLabel('O', '#ffffff', new THREE.Vector3(-0.05, -0.05, 0)));
  
  // Lấy các phần tử DOM
  const sSlider = document.getElementById('s-slider');
  const sValueSpan = document.getElementById('s-value');
  const f1EquationDiv = document.getElementById('f1-equation');
  const f2EquationDiv = document.getElementById('f2-equation');

  let pointsGreen = null;
  let pointsRed = null;

  function updateMathJax(s) {
    const s_str = s.toFixed(2);
    const f1_latex = `$$ \\mathbf{p}' = ${s_str} \\cdot \\left( \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 1/2 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} \\mathbf{p} \\right) $$`;
    const f2_latex = `$$ \\mathbf{p}' = ${s_str} \\cdot \\left( \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 1/2 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} \\mathbf{p} + \\begin{pmatrix} 0 \\\\ 1/2 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right) $$`;
    f1EquationDiv.innerHTML = f1_latex;
    f2EquationDiv.innerHTML = f2_latex;
    if (window.MathJax) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, f1EquationDiv]);
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, f2EquationDiv]);
    }
  }

  function generateFractal(s) {
    // Dọn dẹp attractor cũ
    if (pointsGreen) {
      scene.remove(pointsGreen);
      pointsGreen.geometry.dispose();
      pointsGreen.material.dispose();
    }
    if (pointsRed) {
      scene.remove(pointsRed);
      pointsRed.geometry.dispose();
      pointsRed.material.dispose();
    }

    let x = Math.random(), y = Math.random(), z = Math.random(), w = Math.random();
    const iterations = 200000;
    const positionsRed = [], colorsRed = [];
    const positionsGreen = [], colorsGreen = [];
    const colorRed = new THREE.Color(1, 0.2, 0.2), colorGreen = new THREE.Color(0.2, 1, 0.2);

    function f1(x, y, z, w) {
      let nx = w, ny = 0.5 * x, nz = y, nw = z;
      return [nx * s, ny * s, nz * s, nw * s];
    }
    function f2(x, y, z, w) {
      let nx = w, ny = 0.5 * x + 0.5, nz = y, nw = z;
      return [nx * s, ny * s, nz * s, nw * s];
    }
    
    for(let i = 0; i < 20; i++) {
      [x, y, z, w] = Math.random() < 0.5 ? f1(x, y, z, w) : f2(x, y, z, w);
    }

    for (let i = 0; i < iterations; i++) {
      const choice = Math.random();
      if (choice < 0.5) {
        [x, y, z, w] = f1(x, y, z, w);
        const scale = 1.0 / (1.0 - w);
        positionsGreen.push(x * scale, y * scale, z * scale);
      } else {
        [x, y, z, w] = f2(x, y, z, w);
        const scale = 1.0 / (1.0 - w);
        positionsRed.push(x * scale, y * scale, z * scale);
      }
    }
    
    const material = new THREE.PointsMaterial({ size: 0.008, vertexColors: false, sizeAttenuation: true });
    
    const geometryGreen = new THREE.BufferGeometry();
    geometryGreen.setAttribute('position', new THREE.Float32BufferAttribute(positionsGreen, 3));
    pointsGreen = new THREE.Points(geometryGreen, material.clone());
    pointsGreen.material.color.set(colorGreen);
    scene.add(pointsGreen);
    
    const geometryRed = new THREE.BufferGeometry();
    geometryRed.setAttribute('position', new THREE.Float32BufferAttribute(positionsRed, 3));
    pointsRed = new THREE.Points(geometryRed, material.clone());
    pointsRed.material.color.set(colorRed);
    scene.add(pointsRed);
    
    // Tự động điều chỉnh camera
    const combinedGeometry = new THREE.BufferGeometry();
    combinedGeometry.setAttribute('position', new THREE.Float32BufferAttribute([...positionsGreen, ...positionsRed], 3));
    combinedGeometry.computeBoundingSphere();
    if (combinedGeometry.boundingSphere) {
      const center = combinedGeometry.boundingSphere.center;
      const radius = combinedGeometry.boundingSphere.radius;
      controls.target.copy(center);
      // Ước lượng khoảng cách camera để nhìn rõ
      const distance = radius / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
      camera.position.copy(center).add(new THREE.Vector3(0, 0, distance * 2));
    }
  }

  function regenerate() {
      const s = parseFloat(sSlider.value);
      sValueSpan.textContent = s.toFixed(2);
      updateMathJax(s);
      generateFractal(s);
  }

  sSlider.addEventListener('input', regenerate);
  
  document.getElementById('btn-green').addEventListener('click', () => { pointsGreen.visible = true; pointsRed.visible = false; });
  document.getElementById('btn-red').addEventListener('click', () => { pointsGreen.visible = false; pointsRed.visible = true; });
  document.getElementById('btn-both').addEventListener('click', () => { pointsGreen.visible = true; pointsRed.visible = true; });
  
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  
  window.addEventListener('resize', () => {
    camera.aspect = rightPanel.offsetWidth / rightPanel.offsetHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(rightPanel.offsetWidth, rightPanel.offsetHeight);
    labelRenderer.setSize(rightPanel.offsetWidth, rightPanel.offsetHeight);
  }, false);
  
  regenerate(); // Chạy lần đầu
  animate();
</script>

</body>
</html>