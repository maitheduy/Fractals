<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFS Attractor - Tương tác Pan & Zoom (Hệ mới)</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21; }
        h1 { width: 100%; text-align: center; margin-bottom: 20px; }
        #app-container { display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap; }
        #left-panel { flex: 1 1 420px; min-width: 400px; display: flex; flex-direction: column; gap: 20px; }
        #right-panel { flex: 1 1 600px; min-width: 500px; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #controls-container, #info-container { background-color: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .slider-group { display: flex; flex-direction: column; margin-bottom: 15px; }
        .slider-group label { margin-bottom: 5px; font-weight: 500; }
        input[type="range"] { width: 100%; cursor: pointer; }
        #canvas-container { border: 1px solid #ccc; box-shadow: 0 4px 12px rgba(0,0,0,0.1); background-color: #fff; touch-action: none; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        .formula-display { padding: 10px; font-size: 1.1em; text-align: center; border-top: 1px solid #e0e0e0; margin-top: 15px; }
        .formula-display:first-of-type { border-top: none; margin-top: 5px; }
        #reset-view-btn { padding: 8px 16px; font-size: 14px; font-weight: 500; color: #fff; background-color: #007bff; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; }
        #reset-view-btn:hover { background-color: #0056b3; }
    </style>
</head>
<body>
    <h1>Mô Phỏng Attractor Với Hệ Hàm Co Mới</h1>
    <div id="app-container">
        <div id="left-panel">
            <div id="controls-container">
                <h2>Bảng Điều Khiển</h2>
                <div class="slider-group"><label for="a">a: <span id="a-value"></span></label><input type="range" id="a" min="-5" max="5" value="1" step="0.1"></div>
                <div class="slider-group"><label for="b">b: <span id="b-value"></span></label><input type="range" id="b" min="-5" max="5" value="0" step="0.1"></div>
                <div class="slider-group"><label for="c">c: <span id="c-value"></span></label><input type="range" id="c" min="-5" max="5" value="0" step="0.1"></div>
                <div class="slider-group"><label for="x0">x₀: <span id="x0-value"></span></label><input type="range" id="x0" min="-2" max="2" value="0" step="0.01"></div>
                <div class="slider-group"><label for="x1">x₁: <span id="x1-value"></span></label><input type="range" id="x1" min="-2" max="2" value="0.5" step="0.01"></div>
                <div class="slider-group"><label for="iterations">Số điểm (log): <span id="iterations-value"></span></label><input type="range" id="iterations" min="3" max="5.5" value="4.7" step="0.01"></div>
            </div>
            <div id="info-container">
                <h3>Phép Biến Đổi Affine</h3>
                <p>Điểm <strong style="color:#28a745;">xanh lá</strong> từ f₁, điểm <strong style="color:#ff2828;">đỏ tươi</strong> từ f₂.</p>
                <div id="formula1" class="formula-display"></div>
                <div id="formula2" class="formula-display"></div>
            </div>
        </div>
        <div id="right-panel">
            <div id="canvas-container"><canvas id="attractorCanvas" width="600" height="600"></canvas></div>
            <button id="reset-view-btn">Reset Khung Nhìn</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('attractorCanvas');
        const ctx = canvas.getContext('2d');
        const sliders = { /* ... */ };
        
        // --- Trạng thái khung nhìn (Viewport State) ---
        const STATIC_BOUNDS = { xMin: -1.0, xMax: 2.0, yMin: -2.0, yMax: 2.0 };
        let mathBounds = { ...STATIC_BOUNDS };
        let isPanning = false;
        let lastMousePos = { x: 0, y: 0 };
        let currentParams = {};

        // Hàm chuyển đổi tọa độ
        function transformCoordinates(mx, my) {
            const xRange = mathBounds.xMax - mathBounds.xMin;
            const yRange = mathBounds.yMax - mathBounds.yMin;
            const canvasX = (mx - mathBounds.xMin) / xRange * canvas.width;
            const canvasY = canvas.height - ((my - mathBounds.yMin) / yRange * canvas.height);
            return { x: canvasX, y: canvasY };
        }

        // --- Hàm vẽ ---
        function drawGrid() {
            ctx.strokeStyle = "#e0e0e0"; ctx.lineWidth = 1;
            ctx.font = "11px Arial"; ctx.fillStyle = "#555";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";

            const xRange = mathBounds.xMax - mathBounds.xMin;
            const powerOf10 = Math.pow(10, Math.floor(Math.log10(xRange)));
            const step = xRange / powerOf10 > 5 ? powerOf10 : (xRange / powerOf10 > 2 ? 0.5 * powerOf10 : 0.2 * powerOf10);

            for (let i = Math.floor(mathBounds.xMin / step) * step; i < mathBounds.xMax; i += step) {
                const { x } = transformCoordinates(i, 0);
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                ctx.fillText(i.toFixed(2), x, transformCoordinates(0, mathBounds.yMin).y - 10);
            }
            for (let i = Math.floor(mathBounds.yMin / step) * step; i < mathBounds.yMax; i += step) {
                const { y } = transformCoordinates(0, i);
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                ctx.fillText(i.toFixed(2), transformCoordinates(mathBounds.xMin, 0).x - 25, y);
            }
        }

        function drawAttractor(params) {
            let x = Math.random(), y = Math.random();
            for (let i = 0; i < 20; i++) { [x, y] = (Math.random() < 0.5) ? f1(x, y, params) : f2(x, y, params); }
            
            for (let i = 0; i < params.numPoints; i++) {
                let nextX, nextY, color;
                if (Math.random() < 0.5) { 
                    [nextX, nextY] = f1(x, y, params); 
                    color = 'rgba(40, 167, 69, 0.8)'; // Xanh lá
                } else { 
                    [nextX, nextY] = f2(x, y, params); 
                    color = 'rgba(255, 40, 40, 0.8)'; // Đỏ tươi
                }
                x = nextX; y = nextY;
                const { x: cx, y: cy } = transformCoordinates(x, y);
                if (cx >= -1 && cx <= canvas.width+1 && cy >= -1 && cy <= canvas.height+1) {
                    ctx.fillStyle = color;
                    ctx.fillRect(cx, cy, 2, 2);
                }
            }
        }
        
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAttractor(currentParams);
        }

        function updateAndRedraw() {
            currentParams = {
                a: parseFloat(sliders.a.value), b: parseFloat(sliders.b.value), c: parseFloat(sliders.c.value),
                x0: parseFloat(sliders.x0.value), x1: parseFloat(sliders.x1.value),
                numPoints: Math.floor(Math.pow(10, parseFloat(sliders.iterations.value)))
            };
            updateUI(currentParams);
            drawScene();
        }

        // --- Cập nhật UI và Hàm co ---
        // **HÀM CO MỚI F1**
        function f1(x, y, p) {
            const nextX = 0.5 * x + p.x0;
            const nextY = (p.a * p.x0 + 0.25 * p.b) * x + 0.25 * y + (p.a * p.x0 * p.x0 + p.b * p.x0 + 0.75 * p.c);
            return [nextX, nextY];
        }

        // **HÀM CO MỚI F2**
        function f2(x, y, p) {
            const nextX = 0.5 * x + p.x1;
            const nextY = (p.a * p.x1 + 0.25 * p.b) * x + 0.25 * y + (p.a * p.x1 * p.x1 + p.b * p.x1 + 0.75 * p.c);
            return [nextX, nextY];
        }

        function updateUI(p) {
            document.getElementById('a-value').textContent = p.a.toFixed(1);
            document.getElementById('b-value').textContent = p.b.toFixed(1);
            document.getElementById('c-value').textContent = p.c.toFixed(1);
            document.getElementById('x0-value').textContent = p.x0.toFixed(2);
            document.getElementById('x1-value').textContent = p.x1.toFixed(2);
            document.getElementById('iterations-value').textContent = p.numPoints;
            updateMatrixFormulas(p);
        }

        // **CẬP NHẬT CÔNG THỨC MA TRẬN**
        function updateMatrixFormulas(p) {
            const f = (n) => n.toFixed(2); // Helper
            
            // Ma trận f1
            const m1_21 = p.a * p.x0 + 0.25 * p.b;
            const t1_2 = p.a * p.x0 * p.x0 + p.b * p.x0 + 0.75 * p.c;
            const f1_latex = `\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = 
                \\begin{pmatrix} 0.5 & 0 \\\\ ${f(m1_21)} & 0.25 \\end{pmatrix}
                \\begin{pmatrix} x \\\\ y \\end{pmatrix} + 
                \\begin{pmatrix} ${f(p.x0)} \\\\ ${f(t1_2)} \\end{pmatrix}`;

            // Ma trận f2
            const m2_21 = p.a * p.x1 + 0.25 * p.b;
            const t2_2 = p.a * p.x1 * p.x1 + p.b * p.x1 + 0.75 * p.c;
            const f2_latex = `\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = 
                \\begin{pmatrix} 0.5 & 0 \\\\ ${f(m2_21)} & 0.25 \\end{pmatrix}
                \\begin{pmatrix} x \\\\ y \\end{pmatrix} + 
                \\begin{pmatrix} ${f(p.x1)} \\\\ ${f(t2_2)} \\end{pmatrix}`;

            document.getElementById('formula1').innerHTML = `\\(f_1:\\) $$${f1_latex}$$`;
            document.getElementById('formula2').innerHTML = `\\(f_2:\\) $$${f2_latex}$$`;
            MathJax.typesetPromise();
        }

        // --- Event Handlers cho Pan & Zoom (Giữ nguyên) ---
        canvas.addEventListener('mousedown', (e) => { isPanning = true; lastMousePos = { x: e.offsetX, y: e.offsetY }; });
        window.addEventListener('mouseup', () => { isPanning = false; });
        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.offsetX - lastMousePos.x; const dy = e.offsetY - lastMousePos.y;
            lastMousePos = { x: e.offsetX, y: e.offsetY };
            const xRange = mathBounds.xMax - mathBounds.xMin; const yRange = mathBounds.yMax - mathBounds.yMin;
            mathBounds.xMin -= dx * (xRange / canvas.width); mathBounds.xMax -= dx * (xRange / canvas.width);
            mathBounds.yMin += dy * (yRange / canvas.height); mathBounds.yMax += dy * (yRange / canvas.height);
            drawScene();
        });
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY < 0 ? 0.9 : 1.1;
            const mouseX = e.offsetX; const mouseY = e.offsetY;
            const xRange = mathBounds.xMax - mathBounds.xMin; const yRange = mathBounds.yMax - mathBounds.yMin;
            const mouseMathX = mathBounds.xMin + mouseX * (xRange / canvas.width);
            const mouseMathY = mathBounds.yMin + (canvas.height - mouseY) * (yRange / canvas.height);
            mathBounds.xMin = mouseMathX + (mathBounds.xMin - mouseMathX) * zoomFactor;
            mathBounds.xMax = mouseMathX + (mathBounds.xMax - mouseMathX) * zoomFactor;
            mathBounds.yMin = mouseMathY + (mathBounds.yMin - mouseMathY) * zoomFactor;
            mathBounds.yMax = mouseMathY + (mathBounds.yMax - mouseMathY) * zoomFactor;
            drawScene();
        });
        document.getElementById('reset-view-btn').addEventListener('click', () => {
            mathBounds = { ...STATIC_BOUNDS };
            drawScene();
        });

        // --- Khởi tạo ---
        const sliderIds = ['a', 'b', 'c', 'x0', 'x1', 'iterations'];
        sliderIds.forEach(id => {
            sliders[id] = document.getElementById(id);
            sliders[id].addEventListener('input', updateAndRedraw);
        });
        window.onload = updateAndRedraw;
    </script>
</body>
</html>