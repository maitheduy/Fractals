<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hình vuông Fractal "Dát Vàng" Lá Möbius</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #1a1a1a; color: #e0e0e0; overflow: hidden; }
        #container { display: flex; width: 100vw; height: 100vh; }
        #info-panel { flex: 0 0 50%; padding: 25px; background-color: #2c2c2c; box-shadow: 2px 0 10px rgba(0,0,0,0.5); overflow-y: auto; display: flex; flex-direction: column; }
        #canvas-container { flex-grow: 1; position: relative; }
        h1 { color: #4fc3f7; margin-top: 0; font-size: 1.8em; text-align: center; }
        p { line-height: 1.6; font-size: 1.1em; }
        
        .control-group { margin: 20px 0; }
        label { font-weight: bold; font-size: 1.2em; }
        .slider-container { display: flex; align-items: center; gap: 15px; margin-top: 10px; }
        .slider-container input[type="range"] { flex-grow: 1; cursor: pointer; }
        .slider-container input[type="number"] { width: 60px; padding: 5px; background-color: #555; color: #fff; border: 1px solid #777; border-radius: 4px; font-size: 1em; }

        #equations { background-color: #333; padding: 15px; border-radius: 8px; margin-top: auto; font-size: 1.0em; }
        .equation-title { margin-bottom: 0.2em; margin-top: 1.0em; font-weight: bold; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container">
        <div id="info-panel">
            <h1>Hình vuông Fractal "Dát Vàng" Lá Möbius</h1>
            <p>
                Mô hình này sử dụng attractor 2D (hình vuông) làm "hoa văn" để "dát" lên bề mặt của một Lá Möbius. Xác suất chọn hàm co được tính dựa trên định thức, làm thay đổi sự phân bố của các điểm.
            </p>
            
            <div class="control-group">
                <label for="k-slider">Tham số k = <span id="k-value">0.50</span></label>
                <div class="slider-container">
                    <input type="range" id="k-slider" min="0" max="1" value="0.5" step="0.01">
                    <input type="number" id="k-text" min="0" max="1" value="0.5" step="0.01">
                </div>
            </div>

            <div id="equations"></div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } }; </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let pointsObjects = { f1: null, f2: null };
        const NUM_POINTS = 100000;

        const kSlider = document.getElementById('k-slider');
        const kText = document.getElementById('k-text');
        const kValueSpan = document.getElementById('k-value');
        const equationsDiv = document.getElementById('equations');
        const canvasContainer = document.getElementById('canvas-container');

        function updateMathJax(k, p1, p2) {
            const h1 = `\\mathbf{h}_1(u,v) = \\begin{pmatrix} 0 & 1 \\\\ ${k.toFixed(2)} & 0 \\end{pmatrix} \\begin{pmatrix} u \\\\ v \\end{pmatrix}`;
            const h2 = `\\mathbf{h}_2(u,v) = \\begin{pmatrix} 0 & 1 \\\\ ${ (1-k).toFixed(2) } & 0 \\end{pmatrix} \\begin{pmatrix} u \\\\ v \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ ${k.toFixed(2)} \\end{pmatrix}`;
            
            const prob = `p_1 = \\frac{|\\det(M_1)|}{|\\det(M_1)|+|\\det(M_2)|} = \\frac{${k.toFixed(2)}}{${k.toFixed(2)} + ${(1-k).toFixed(2)}} = ${p1.toFixed(2)}`;

            const mapping = `\\mathbf{M}(u,v) = 
            \\begin{cases} 
                x = (R + w \\cos(\\theta/2)) \\cos(\\theta) \\\\ 
                y = (R + w \\cos(\\theta/2)) \\sin(\\theta) \\\\ 
                z = w \\sin(\\theta/2) 
            \\end{cases}`;

            equationsDiv.innerHTML = `
                <p class="equation-title">Hệ IFS Nguồn (trên không gian tham số u,v):</p>
                $$ ${h1} \\quad , \\quad ${h2} $$
                <p class="equation-title">Xác suất lựa chọn:</p>
                $$ ${prob} \\quad , \\quad p_2 = 1 - p_1 = ${p2.toFixed(2)} $$
                <p class="equation-title">Hàm Ánh xạ "Dát Vàng" lên Lá Möbius:</p>
                $$ ${mapping} $$
                <p style="font-size:0.9em; text-align:center;">Với $\\theta=u \\cdot 2\\pi$ và $w=(v-0.5) \\cdot \\text{width}$.</p>
            `;

            if (window.MathJax && window.MathJax.typeset) {
                MathJax.typesetPromise([equationsDiv]).catch((err) => console.log('MathJax error:', err));
            }
        }

        function generateFractal(k, p1) {
            Object.values(pointsObjects).forEach(obj => { if (obj) { obj.geometry.dispose(); obj.material.dispose(); scene.remove(obj); } });
            pointsObjects = { f1: null, f2: null };

            const positions_f1 = [], positions_f2 = [];
            const R = 1.2, width = 0.6;
            let p_uv = { u: Math.random(), v: Math.random() };

            const to3D = (u, v) => {
                const theta = u * 2 * Math.PI;
                const w = (v - 0.5) * width;
                return {
                    x: (R + w * Math.cos(theta / 2)) * Math.cos(theta),
                    y: (R + w * Math.cos(theta / 2)) * Math.sin(theta),
                    z: w * Math.sin(theta / 2)
                };
            };
            
            for (let i = 0; i < NUM_POINTS; i++) {
                let nu, nv;
                let targetArray;

                if (Math.random() < p1) { // h1
                    nu = p_uv.v;
                    nv = k * p_uv.u;
                    targetArray = positions_f1;
                } else { // h2
                    nu = p_uv.v;
                    nv = (1 - k) * p_uv.u + k;
                    targetArray = positions_f2;
                }
                p_uv = { u: nu, v: nv };

                if (i > 20) {
                    const p3d = to3D(p_uv.u, p_uv.v);
                    targetArray.push(p3d.x, p3d.y, p3d.z);
                }
            }
            
            const createPoints = (pos, color) => {
                if (pos.length === 0) return null;
                const geom = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                return new THREE.Points(geom, new THREE.PointsMaterial({ color: color, size: 0.015 }));
            };
            
            pointsObjects.f1 = createPoints(positions_f1, 0x76ff03); // Xanh lá
            pointsObjects.f2 = createPoints(positions_f2, 0xff1744); // Đỏ tươi
            Object.values(pointsObjects).forEach(obj => { if (obj) scene.add(obj); });
        }
        
        function regenerate() {
            const k = parseFloat(kSlider.value);
            kValueSpan.textContent = k.toFixed(2);
            if (document.activeElement !== kText) {
                kText.value = k.toFixed(2);
            }
            const det1 = k;
            const det2 = 1 - k;
            const totalDet = det1 + det2;
            const p1 = (totalDet > 0) ? det1 / totalDet : 0.5; // p1 = k
            const p2 = 1 - p1;
            updateMathJax(k, p1, p2);
            generateFractal(k, p1);
        }

        function createLabeledAxes(size) {
            const group = new THREE.Group(); const axesHelper = new THREE.AxesHelper(size); group.add(axesHelper);
            const materialX = new THREE.MeshBasicMaterial({ color: 0xff0000 }); const materialY = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); const materialZ = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const coneRadius = size * 0.03; const coneHeight = size * 0.1; const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const arrowX = new THREE.Mesh(coneGeometry, materialX); arrowX.position.set(size, 0, 0); arrowX.rotation.z = -Math.PI / 2; group.add(arrowX);
            const arrowY = new THREE.Mesh(coneGeometry, materialY); arrowY.position.set(0, size, 0); group.add(arrowY);
            const arrowZ = new THREE.Mesh(coneGeometry, materialZ); arrowZ.position.set(0, 0, size); arrowZ.rotation.x = Math.PI / 2; group.add(arrowZ);
            const createAxisLabel = (text, color, position) => { const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const size = 64; canvas.width = size; canvas.height = size; context.font = `Bold ${size/2}px Arial`; context.fillStyle = color; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, size / 2, size / 2); const texture = new THREE.CanvasTexture(canvas); const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true }); const sprite = new THREE.Sprite(spriteMaterial); sprite.scale.set(0.3, 0.3, 1.0); sprite.position.copy(position); return sprite; };
            group.add(createAxisLabel('X', '#ff7777', new THREE.Vector3(size + coneHeight, 0, 0)), createAxisLabel('Y', '#77ff77', new THREE.Vector3(0, size + coneHeight, 0)), createAxisLabel('Z', '#7777ff', new THREE.Vector3(0, 0, size + coneHeight)));
            return group;
        }
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(1.8, 1.8, 1.8);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(1, 1, 1); scene.add(directionalLight);
            scene.add(createLabeledAxes(1.5));
            
            kSlider.addEventListener('input', (e) => {
                kText.value = parseFloat(e.target.value).toFixed(2);
                regenerate();
            });
            kText.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (isNaN(val)) return;
                val = Math.max(0, Math.min(1, val));
                kSlider.value = val;
                regenerate();
            });

            window.addEventListener('resize', () => { if (canvasContainer) { camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); }});
            
            regenerate();
            (function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); })();
        }

        init();
    </script>
</body>
</html>