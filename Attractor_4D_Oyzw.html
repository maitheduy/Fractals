<!DOCTYPE html>
<html>
<head>
<title>4D Attractor - Oyzw Projection</title>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<style>
  body { font-family: sans-serif; display: flex; height: 100vh; margin: 0; overflow: hidden; }
  #left-panel { width: 40%; padding: 20px; box-sizing: border-box; background-color: #2c3e50; color: #ecf0f1; overflow-y: auto; }
  #left-panel h2, #left-panel h3 { color: #ffffff; border-bottom: 1px solid #34495e; padding-bottom: 10px; margin-top: 20px; }
  #right-panel { width: 60%; position: relative; background-color: #111; }
  canvas { display: block; }

  .axis-label {
    font-size: 16px; font-family: 'Courier New', monospace; font-weight: bold;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
  }
  .control-group { margin-top: 15px; }
  .control-group label { font-weight: bold; }
  .control-group input[type="range"] { width: 100%; cursor: pointer; }
  #controls { display: flex; gap: 10px; margin-top: 15px; }
  .control-btn {
    flex-grow: 1; padding: 10px; font-size: 14px; cursor: pointer;
    background-color: #34495e; color: #ecf0f1; border: 1px solid #4a627a;
    border-radius: 4px; transition: background-color 0.2s;
  }
  .control-btn:hover { background-color: #4a627a; }
</style>
</head>
<body>

<div id="left-panel">
  <h2>Attractor 4D (Chiếu xuống Oyzw)</h2>
  <div class="control-group">
      <label for="s-slider">Hệ số s = <span id="s-value">0.95</span></label>
      <input type="range" id="s-slider" min="0.8" max="1.2" value="0.95" step="0.01">
  </div>
  <p>Cảnh bên phải hiển thị hình chiếu của attractor 4D xuống không gian 3 chiều Oyzw. Trục X của không gian 4D được dùng cho chiều sâu của phép chiếu.</p>

  <h3>Hệ trục tọa độ 3D:</h3>
  <ul>
    <li><b>Trục Đỏ:</b> Trục Y</li>
    <li><b>Trục Xanh lá:</b> Trục Z</li>
    <li><b>Trục Xanh dương:</b> Trục W</li>
  </ul>
  
  <div id="math-equations-container">
      <h3>Hệ hàm co/giãn</h3>
      <p>Hàm \(f_1\) (mảnh xanh):</p>
      <div id="f1-equation"></div>
      <p>Hàm \(f_2\) (mảnh đỏ):</p>
      <div id="f2-equation"></div>
  </div>

  <h3>Điều khiển Hiển thị</h3>
  <div id="controls">
    <button id="btn-green" class="control-btn">Chỉ mảnh Xanh</button>
    <button id="btn-red" class="control-btn">Chỉ mảnh Đỏ</button>
    <button id="btn-both" class="control-btn">Cả hai mảnh</button>
  </div>
</div>

<div id="right-panel"></div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" }}
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

  const rightPanel = document.getElementById('right-panel');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, rightPanel.clientWidth / rightPanel.clientHeight, 0.1, 100);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  const labelRenderer = new CSS2DRenderer();
  const controls = new OrbitControls(camera, renderer.domElement);
  
  const f1EquationDiv = document.getElementById('f1-equation');
  const f2EquationDiv = document.getElementById('f2-equation');

  let pointsGreen = null, pointsRed = null;

  function updateMathJax(s) {
    const s_str = s.toFixed(2);
    const matrix_latex = `\\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 1/2 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}`;
    const f1_latex = `$$ \\mathbf{p}' = ${s_str} \\cdot \\left( ${matrix_latex} \\mathbf{p} \\right) $$`;
    const f2_latex = `$$ \\mathbf{p}' = ${s_str} \\cdot \\left( ${matrix_latex} \\mathbf{p} + \\begin{pmatrix} 0 \\\\ 1/2 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right) $$`;
    f1EquationDiv.innerHTML = f1_latex;
    f2EquationDiv.innerHTML = f2_latex;
    if (window.MathJax && MathJax.Hub) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
  
  function setupScene() {
      scene.background = new THREE.Color(0x111111);
      camera.position.set(0, 0, 3.5);
      
      renderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);
      rightPanel.appendChild(renderer.domElement);
      
      labelRenderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);
      labelRenderer.domElement.style.position = 'absolute';
      labelRenderer.domElement.style.top = '0px';
      labelRenderer.domElement.style.pointerEvents = 'none';
      rightPanel.appendChild(labelRenderer.domElement);
      
      controls.enableDamping = true;

      const grid = new THREE.GridHelper(4, 10, 0x444444, 0x888888);
      scene.add(grid);

      const axisLength = 2.0;
      scene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), axisLength, 0xff0000)); // Trục 3D-X (Đỏ)
      scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), axisLength, 0x00ff00)); // Trục 3D-Y (Xanh lá)
      scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), axisLength, 0x0000ff)); // Trục 3D-Z (Xanh dương)

      const createLabel = (text, color, pos) => {
          const div = document.createElement('div');
          div.className = 'axis-label'; div.textContent = text; div.style.color = color;
          const label = new CSS2DObject(div); label.position.copy(pos);
          return label;
      };
      // Gán nhãn tương ứng với không gian chiếu Oyzw
      scene.add(createLabel('Y', '#ff0000', new THREE.Vector3(axisLength + 0.2, 0, 0)));
      scene.add(createLabel('Z', '#00ff00', new THREE.Vector3(0, axisLength + 0.2, 0)));
      scene.add(createLabel('W', '#00aaff', new THREE.Vector3(0, 0, axisLength + 0.2)));
  }
  
  function generateFractal(s) {
      if (pointsGreen) { scene.remove(pointsGreen); pointsGreen.geometry.dispose(); }
      if (pointsRed) { scene.remove(pointsRed); pointsRed.geometry.dispose(); }

      let x=0.1, y=0.1, z=0.1, w=0.1;
      const iterations = 150000;
      const rawPoints4D = [];

      const f1 = (x,y,z,w) => [s*w, s*(0.5*x), s*y, s*z];
      const f2 = (x,y,z,w) => [s*w, s*(0.5*x + 0.5), s*y, s*z];

      for(let i=0; i<20; ++i) { [x,y,z,w] = Math.random()<0.5 ? f1(x,y,z,w) : f2(x,y,z,w); }
      for(let i=0; i<iterations; ++i) {
          const choice = Math.random() < 0.5 ? 1 : 2;
          [x,y,z,w] = (choice === 1) ? f1(x,y,z,w) : f2(x,y,z,w);
          rawPoints4D.push({x,y,z,w, choice});
      }

      let sumX=0, sumY=0, sumZ=0, sumW=0;
      for (const p of rawPoints4D) { sumX+=p.x; sumY+=p.y; sumZ+=p.z; sumW+=p.w; }
      const center4D = { x: sumX/iterations, y: sumY/iterations, z: sumZ/iterations, w: sumW/iterations };

      const positionsGreen = [], positionsRed = [];
      const distance = 2.0;

      for (const p of rawPoints4D) {
          let cx=p.x-center4D.x, cy=p.y-center4D.y, cz=p.z-center4D.z, cw=p.w-center4D.w;
          const len = Math.sqrt(cx*cx + cy*cy + cz*cz + cw*cw);
          if (len > 0) { cx/=len; cy/=len; cz/=len; cw/=len; }
          
          // --- THAY ĐỔI PHÉP CHIẾU SANG OYZW ---
          const scale = distance / (distance - cx); // Dùng X làm chiều sâu
          const projY_as_X = cy * scale; // Trục Y của 4D trở thành trục X của cảnh 3D
          const projZ_as_Y = cz * scale; // Trục Z của 4D trở thành trục Y của cảnh 3D
          const projW_as_Z = cw * scale; // Trục W của 4D trở thành trục Z của cảnh 3D
          // -------------------------------------

          if (p.choice === 1) { positionsGreen.push(projY_as_X, projZ_as_Y, projW_as_Z); }
          else { positionsRed.push(projY_as_X, projZ_as_Y, projW_as_Z); }
      }
      
      const material = new THREE.PointsMaterial({ size: 0.015, sizeAttenuation: true });
      
      const geomGreen = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(positionsGreen, 3));
      pointsGreen = new THREE.Points(geomGreen, material.clone());
      pointsGreen.material.color.setHSL(0.33, 1, 0.5);
      scene.add(pointsGreen);

      const geomRed = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(positionsRed, 3));
      pointsRed = new THREE.Points(geomRed, material.clone());
      pointsRed.material.color.setHSL(0, 1, 0.5);
      scene.add(pointsRed);
      
      const combinedGeometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([...positionsGreen, ...positionsRed], 3));
      combinedGeometry.computeBoundingSphere();
      if (combinedGeometry.boundingSphere) {
          const sphere = combinedGeometry.boundingSphere;
          controls.target.copy(sphere.center);
          const camDistance = sphere.radius / Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
          camera.position.copy(sphere.center).add(new THREE.Vector3(0, 0, camDistance * 1.5));
          camera.lookAt(sphere.center);
      }
      combinedGeometry.dispose();
  }

  function regenerate() {
      const s = parseFloat(document.getElementById('s-slider').value);
      document.getElementById('s-value').textContent = s.toFixed(2);
      updateMathJax(s);
      generateFractal(s);
  }

  document.getElementById('s-slider').addEventListener('input', regenerate);
  document.getElementById('btn-green').addEventListener('click', () => { if(pointsGreen) { pointsGreen.visible = true; pointsRed.visible = false; }});
  document.getElementById('btn-red').addEventListener('click', () => { if(pointsRed) { pointsGreen.visible = false; pointsRed.visible = true; }});
  document.getElementById('btn-both').addEventListener('click', () => { if(pointsGreen) { pointsGreen.visible = true; pointsRed.visible = true; }});

  window.addEventListener('resize', () => {
      camera.aspect = rightPanel.clientWidth / rightPanel.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);
      labelRenderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);
  }, false);
  
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }
  
  setupScene();
  regenerate();
  animate();
</script>

</body>
</html>