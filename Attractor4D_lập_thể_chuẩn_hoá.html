<!DOCTYPE html>
<html>
<head>
<title>4D Attractor - 4 Normalized Projections</title>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<style>
  body { font-family: sans-serif; display: flex; height: 100vh; margin: 0; overflow: hidden; }
  #left-panel { width: 40%; padding: 20px; box-sizing: border-box; background-color: #2c3e50; color: #ecf0f1; overflow-y: auto; }
  #left-panel h2, #left-panel h3 { color: #ffffff; border-bottom: 1px solid #34495e; padding-bottom: 10px; margin-top: 20px; }
  #left-panel ul { padding-left: 20px; }
  #left-panel li { margin-bottom: 10px; }
  
  #right-panel {
    width: 60%; display: grid; grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr; gap: 4px; background-color: #444;
  }
  .viewport { position: relative; background-color: #111; overflow: hidden; }
  .viewport-title {
    position: absolute; top: 10px; left: 10px; color: #fff; font-size: 14px;
    font-family: 'Courier New', monospace; background-color: rgba(0,0,0,0.5);
    padding: 2px 5px; border-radius: 3px; pointer-events: none;
  }
  .control-group { margin-top: 15px; }
  .control-group label { font-weight: bold; }
  .control-group input[type="range"] { width: 100%; cursor: pointer; }
  #controls { display: flex; gap: 10px; margin-top: 15px; }
  .control-btn { flex-grow: 1; padding: 10px; font-size: 14px; cursor: pointer;
    background-color: #34495e; color: #ecf0f1; border: 1px solid #4a627a;
    border-radius: 4px; transition: background-color 0.2s; }
  .control-btn:hover { background-color: #4a627a; }
</style>
</head>
<body>

<div id="left-panel">
  <h2>Attractor 4D (4 Phép chiếu Chuẩn hóa)</h2>
  <div class="control-group">
      <label for="s-slider">Hệ số s = <span id="s-value">0.95</span></label>
      <input type="range" id="s-slider" min="0.8" max="1.2" value="0.95" step="0.01">
  </div>
  
  <h3>Hệ hàm co/giãn</h3>
  <p>Hàm \(f_1\) (mảnh xanh):</p>
  <div id="f1-equation"></div>
  <p>Hàm \(f_2\) (mảnh đỏ):</p>
  <div id="f2-equation"></div>

  <!-- PHẦN CHÚ THÍCH VỀ LỢI ÍCH ĐÃ THÊM VÀO -->
  <h3>Lợi ích của Phép chiếu Chuẩn hóa</h3>
  <p>Phương pháp này cho phép chúng ta khám phá các thuộc tính sâu hơn của đối tượng 4D gốc:</p>
  <ul>
      <li>
          <b>Tập trung vào Cấu trúc & Liên kết (Topo):</b> Bằng cách bỏ qua kích thước và hình dạng tổng thể, phép chiếu này giúp ta chỉ tập trung phân tích "bộ xương" bên trong của đối tượng: nó có lỗ không, các nhánh kết nối ra sao.
      </li>
      <li>
          <b>Ổn định & Dễ quan sát:</b> Mọi điểm được "ép" lên một siêu cầu trước khi chiếu, do đó không có điểm nào bị "bắn" ra vô cực. Kết quả luôn gọn gàng và dễ quan sát.
      </li>
      <li>
          <b>Dễ dàng so sánh:</b> Vì kết quả luôn được "đóng gói" trong một khối cầu, ta có thể dễ dàng so sánh sự thay đổi cấu trúc bên trong khi thay đổi tham số <code>s</code>.
      </li>
       <li>
          <b>Làm nổi bật sự Phân bố Hướng:</b> Hiện tượng khối cầu đặc ở <code>s=1</code> cho thấy attractor 4D gốc phân bố điểm ra mọi hướng một cách đồng đều. Những vùng dày đặc trong hình chiếu 3D tương ứng với các hướng mà attractor gốc ưu tiên.
      </li>
  </ul>


  <h3>Điều khiển Hiển thị</h3>
  <div id="controls">
    <button id="btn-green" class="control-btn">Chỉ mảnh Xanh</button>
    <button id="btn-red" class="control-btn">Chỉ mảnh Đỏ</button>
    <button id="btn-both" class="control-btn">Cả hai mảnh</button>
  </div>
</div>

<div id="right-panel">
  <div id="view-oxyz" class="viewport"><div class="viewport-title">Oxyz (from w)</div></div>
  <div id="view-oxyw" class="viewport"><div class="viewport-title">Oxyw (from z)</div></div>
  <div id="view-oxzw" class="viewport"><div class="viewport-title">Oxzw (from y)</div></div>
  <div id="view-oyzw" class="viewport"><div class="viewport-title">Oyzw (from x)</div></div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" }}
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  const f1EquationDiv = document.getElementById('f1-equation');
  const f2EquationDiv = document.getElementById('f2-equation');
  function updateMathJax(s) {
    const s_str = s.toFixed(2);
    const matrix_latex = `\\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 1/2 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}`;
    const f1_latex = `$$ \\mathbf{p}' = ${s_str} \\cdot \\left( ${matrix_latex} \\mathbf{p} \\right) $$`;
    const f2_latex = `$$ \\mathbf{p}' = ${s_str} \\cdot \\left( ${matrix_latex} \\mathbf{p} + \\begin{pmatrix} 0 \\\\ 1/2 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right) $$`;
    f1EquationDiv.innerHTML = f1_latex;
    f2EquationDiv.innerHTML = f2_latex;
    if (window.MathJax && MathJax.Hub) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }

  class ViewportManager {
    constructor(container, projectionFn) {
        this.container = container;
        this.projectionFn = projectionFn;
        this.pointsGreen = null;
        this.pointsRed = null;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 100);
        this.camera.position.set(0, 0, 3.5);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        container.appendChild(this.renderer.domElement);
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        const grid = new THREE.GridHelper(4, 10, 0x444444, 0x888888);
        this.scene.add(grid);
    }
    update(normalizedPoints4D) {
        if (this.pointsGreen) { this.scene.remove(this.pointsGreen); this.pointsGreen.geometry.dispose(); }
        if (this.pointsRed) { this.scene.remove(this.pointsRed); this.pointsRed.geometry.dispose(); }
        const positionsGreen = [], positionsRed = [];
        const distance = 2.0;
        for (const p of normalizedPoints4D) {
            const projectedPoint = this.projectionFn(p.x, p.y, p.z, p.w, distance);
            if (projectedPoint) {
                if (p.choice === 1) { positionsGreen.push(projectedPoint.x, projectedPoint.y, projectedPoint.z); }
                else { positionsRed.push(projectedPoint.x, projectedPoint.y, projectedPoint.z); }
            }
        }
        const material = new THREE.PointsMaterial({ size: 0.015, sizeAttenuation: true });
        const geomGreen = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(positionsGreen, 3));
        this.pointsGreen = new THREE.Points(geomGreen, material.clone());
        this.pointsGreen.material.color.setHSL(0.33, 1, 0.5);
        this.scene.add(this.pointsGreen);
        const geomRed = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(positionsRed, 3));
        this.pointsRed = new THREE.Points(geomRed, material.clone());
        this.pointsRed.material.color.setHSL(0, 1, 0.5);
        this.scene.add(this.pointsRed);
        const combinedGeometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([...positionsGreen, ...positionsRed], 3));
        combinedGeometry.computeBoundingSphere();
        if (combinedGeometry.boundingSphere && combinedGeometry.boundingSphere.radius > 0) {
            const sphere = combinedGeometry.boundingSphere;
            this.controls.target.copy(sphere.center);
            const camDistance = sphere.radius / Math.tan(THREE.MathUtils.degToRad(this.camera.fov / 2));
            this.camera.position.copy(sphere.center).add(new THREE.Vector3(0, 0, camDistance * 1.5));
            this.camera.lookAt(sphere.center);
        }
        combinedGeometry.dispose();
    }
    render() { this.controls.update(); this.renderer.render(this.scene, this.camera); }
    resize() {
        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    }
    setVisibility(showGreen, showRed) {
        if (this.pointsGreen) this.pointsGreen.visible = showGreen;
        if (this.pointsRed) this.pointsRed.visible = showRed;
    }
  }
  
  const createProjection = (dim) => {
      return (x,y,z,w,d) => {
          let depth_coord;
          switch(dim) {
              case 'w': depth_coord = w; break; case 'z': depth_coord = z; break;
              case 'y': depth_coord = y; break; case 'x': depth_coord = x; break;
          }
          if (Math.abs(d - depth_coord) < 1e-6) return null;
          const scale = d / (d - depth_coord);
          switch(dim) {
              case 'w': return { x: x*scale, y: y*scale, z: z*scale };
              case 'z': return { x: x*scale, y: y*scale, z: w*scale };
              case 'y': return { x: x*scale, y: z*scale, z: w*scale };
              case 'x': return { x: y*scale, y: z*scale, z: w*scale };
          }
      };
  };

  const viewports = [
      new ViewportManager(document.getElementById('view-oxyz'), createProjection('w')),
      new ViewportManager(document.getElementById('view-oxyw'), createProjection('z')),
      new ViewportManager(document.getElementById('view-oxzw'), createProjection('y')),
      new ViewportManager(document.getElementById('view-oyzw'), createProjection('x'))
  ];

  function generateFractal(s) {
    let x=0.1, y=0.1, z=0.1, w=0.1;
    const iterations = 100000;
    const rawPoints4D = [];
    const f1 = (x,y,z,w) => [s*w, s*(0.5*x), s*y, s*z];
    const f2 = (x,y,z,w) => [s*w, s*(0.5*x + 0.5), s*y, s*z];
    for(let i=0; i<20; ++i) { [x,y,z,w] = Math.random()<0.5 ? f1(x,y,z,w) : f2(x,y,z,w); }
    for(let i=0; i<iterations; ++i) {
        const choice = Math.random() < 0.5 ? 1 : 2;
        [x,y,z,w] = (choice === 1) ? f1(x,y,z,w) : f2(x,y,z,w);
        rawPoints4D.push({x,y,z,w, choice});
    }

    let sumX=0, sumY=0, sumZ=0, sumW=0;
    for (const p of rawPoints4D) { sumX+=p.x; sumY+=p.y; sumZ+=p.z; sumW+=p.w; }
    const center4D = { x: sumX/iterations, y: sumY/iterations, z: sumZ/iterations, w: sumW/iterations };
    
    const normalizedPoints4D = [];
    for (const p of rawPoints4D) {
        let cx = p.x - center4D.x, cy = p.y - center4D.y;
        let cz = p.z - center4D.z, cw = p.w - center4D.w;
        const len = Math.sqrt(cx*cx + cy*cy + cz*cz + cw*cw);
        if (len > 0) { cx /= len; cy /= len; cz /= len; cw /= len; }
        normalizedPoints4D.push({ x: cx, y: cy, z: cz, w: cw, choice: p.choice });
    }
    viewports.forEach(vp => vp.update(normalizedPoints4D));
  }

  function regenerate() {
      const s = parseFloat(document.getElementById('s-slider').value);
      document.getElementById('s-value').textContent = s.toFixed(2);
      updateMathJax(s);
      generateFractal(s);
  }

  document.getElementById('s-slider').addEventListener('input', regenerate);
  document.getElementById('btn-green').addEventListener('click', () => viewports.forEach(vp => vp.setVisibility(true, false)));
  document.getElementById('btn-red').addEventListener('click', () => viewports.forEach(vp => vp.setVisibility(false, true)));
  document.getElementById('btn-both').addEventListener('click', () => viewports.forEach(vp => vp.setVisibility(true, true)));

  window.addEventListener('resize', () => viewports.forEach(vp => vp.resize()), false);
  
  function animate() {
    requestAnimationFrame(animate);
    viewports.forEach(vp => vp.render());
  }
  
  viewports.forEach(vp => vp.resize());
  regenerate();
  animate();
</script>

</body>
</html>