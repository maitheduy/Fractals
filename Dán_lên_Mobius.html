<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>So sánh Dán/Bọc Fractal trên Dải băng Thắt nút</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #1a1a1a; color: #e0e0e0; overflow: hidden; }
        #container { display: flex; width: 100vw; height: 100vh; }
        #info-panel { flex: 0 0 45%; padding: 25px; background-color: #2c2c2c; box-shadow: 2px 0 10px rgba(0,0,0,0.5); overflow-y: auto; display: flex; flex-direction: column; }
        #canvas-container { flex-grow: 1; position: relative; }
        h1 { color: #4fc3f7; margin-top: 0; font-size: 1.8em; text-align: center; }
        p { line-height: 1.6; font-size: 1.1em; }
        .control-group { margin: 15px 0; padding: 10px; border-left: 3px solid #444; }
        label { font-weight: bold; font-size: 1.2em; }
        .radio-group { display: flex; flex-direction: column; gap: 8px; align-items: flex-start; margin-top: 10px;}
        .radio-group div { display: flex; align-items: center; }
        .radio-group input[type="radio"] { margin-right: 10px; cursor: pointer; }
        .radio-group label { font-weight: normal; margin-bottom: 0; }
        .slider-container { display: flex; align-items: center; gap: 15px; margin-top: 10px; }
        .slider-container input[type="range"] { flex-grow: 1; cursor: pointer; }
        .slider-container input[type="number"] { width: 70px; padding: 5px; background-color: #555; color: #fff; border: 1px solid #777; border-radius: 4px; font-size: 1em; }
        #equations { background-color: #333; padding: 15px; border-radius: 8px; margin-top: auto; font-size: 1.0em; }
        .equation-title { margin-bottom: 0.2em; margin-top: 1.0em; font-weight: bold; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container">
        <div id="info-panel">
            <h1 id="title-text"></h1>
            <div id="explanation-text"></div>
            
            <div class="control-group">
                <label>1. Chọn Phương pháp</label>
                <div class="radio-group">
                    <div>
                        <input type="radio" id="mode-glue" name="mode" value="glue" checked>
                        <label for="mode-glue">Phép Dán (Tôpô)</label>
                    </div>
                    <div>
                        <input type="radio" id="mode-wrap" name="mode" value="wrap">
                        <label for="mode-wrap">Phép Bọc (Tham số)</label>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>2. Hiển thị Mảnh</label>
                <div class="radio-group">
                    <div><input type="radio" id="vis-both" name="visibility" value="both" checked><label for="vis-both">Hiện cả hai mảnh</label></div>
                    <div><input type="radio" id="vis-green" name="visibility" value="green"><label for="vis-green" style="color:#76ff03;">Chỉ hiện mảnh Xanh lá</label></div>
                    <div><input type="radio" id="vis-red" name="visibility" value="red"><label for="vis-red" style="color:#ff1744;">Chỉ hiện mảnh Đỏ tươi</label></div>
                </div>
            </div>
            
            <div class="control-group">
                <label>3. Tinh chỉnh Tham số Cơ bản</label>
                <div class="slider-container">
                    <label for="k-slider">k = <span id="k-value">0.50</span></label>
                    <input type="range" id="k-slider" min="0.01" max="0.99" value="0.5" step="0.01">
                </div>
                <div class="slider-container">
                    <label for="p-slider">Rộng (p) = <span id="p-value">0.60</span></label>
                    <input type="range" id="p-slider" min="0.1" max="1.5" value="0.6" step="0.01">
                </div>
            </div>
            
            <div id="translation-controls" class="control-group">
                 <label>4. Dịch chuyển Tôpô (chỉ cho chế độ "Dán")</label>
                 <div class="slider-container">
                    <label for="tx-slider">t<sub>x</sub> = <span id="tx-value">0.00</span></label>
                    <input type="range" id="tx-slider" min="-1.0" max="1.0" value="0.0" step="0.01">
                 </div>
                 <div class="slider-container">
                    <label for="ty-slider">t<sub>y</sub> = <span id="ty-value">0.00</span></label>
                    <input type="range" id="ty-slider" min="-1.0" max="1.0" value="0.0" step="0.01">
                 </div>
            </div>

            <div id="equations"></div>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } }; </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

        let scene, camera, renderer, controls;
        let pointsObjects = [];
        let ribbonMesh = null; 

        const NUM_POINTS = 150000;
        const R = 0.8; 
        let ribbonWidth = 0.6; 

        const ui = {
            title: document.getElementById('title-text'),
            explanation: document.getElementById('explanation-text'),
            equations: document.getElementById('equations'),
            canvasContainer: document.getElementById('canvas-container'),
            modeControls: document.querySelectorAll('input[name="mode"]'),
            visibilityControls: document.querySelectorAll('input[name="visibility"]'),
            kSlider: document.getElementById('k-slider'),
            kValue: document.getElementById('k-value'),
            pSlider: document.getElementById('p-slider'),
            pValue: document.getElementById('p-value'),
            txSlider: document.getElementById('tx-slider'),
            txValue: document.getElementById('tx-value'),
            tySlider: document.getElementById('ty-slider'),
            tyValue: document.getElementById('ty-value'),
            translationControls: document.getElementById('translation-controls'),
        };

        function updateMathJax(k, tx, ty) {
            let f1_latex = `\\mathbf{f}_1(x,y) = \\begin{pmatrix} y \\\\ ${k.toFixed(2)}x \\end{pmatrix}`;
            let f2_latex = `\\mathbf{f}_2(x,y) = \\begin{pmatrix} y \\\\ ${(1-k).toFixed(2)}x + ${k.toFixed(2)} \\end{pmatrix}`;
            if (document.querySelector('input[name="mode"]:checked').value === 'glue') {
                 f1_latex += ` + \\begin{pmatrix} ${tx.toFixed(2)} \\\\ ${ty.toFixed(2)} \\end{pmatrix}`;
                 f2_latex += ` + \\begin{pmatrix} ${tx.toFixed(2)} \\\\ ${ty.toFixed(2)} \\end{pmatrix}`;
            }
            ui.equations.innerHTML = `<p class="equation-title">Hệ IFS tạo attractor 2D (x,y):</p><p style="color:#76ff03;">$$ ${f1_latex} $$</p> <p style="color:#ff1744;">$$ ${f2_latex} $$</p>`;
            if (window.MathJax && window.MathJax.typesetPromise) { MathJax.typesetPromise([ui.equations]); }
        }

        function applyRibbonTopology(p) { return { x: p.x - Math.floor(p.x), y: p.y }; }
        const c = (t) => new THREE.Vector3(R * (Math.sin(t) + 2 * Math.sin(2 * t)), R * (Math.cos(t) - 2 * Math.cos(2 * t)), R * (-Math.sin(3 * t)));
        const c_prime = (t) => new THREE.Vector3(R * (Math.cos(t) + 4 * Math.cos(2 * t)), R * (-Math.sin(t) + 4 * Math.sin(2 * t)), R * (-3 * Math.cos(3 * t)));
        const getFrenetFrame = (t) => {
            const T = c_prime(t).normalize(); const T_p = c_prime(t + 0.0001).normalize();
            const N = new THREE.Vector3().subVectors(T_p, T).divideScalar(0.0001).normalize(); return { N };
        };
        function mapToRibbon(x_fractal, y_fractal) {
            const t = x_fractal * 2 * Math.PI; const v = (y_fractal - 0.5) * ribbonWidth;
            const frame = getFrenetFrame(t); const centerPoint = c(t);
            return centerPoint.clone().addScaledVector(frame.N, v);
        }
        
        function createLabeledAxes(size) { /* ... Giữ nguyên như code trước ... */ }

        function generateFractalPoints(mode, k, tx, ty) {
            pointsObjects.forEach(obj => { obj.geometry.dispose(); obj.material.dispose(); scene.remove(obj); });
            pointsObjects = [];
            const attractorPoints2D = [[], []];
            let p_xy = { x: Math.random(), y: Math.random() }; const p1 = k;

            if (mode === 'glue') {
                for (let i = 0; i < NUM_POINTS; i++) {
                    let nx, ny, choice;
                    if (Math.random() < p1) { nx = p_xy.y; ny = k * p_xy.x; choice = 0; } 
                    else { nx = p_xy.y; ny = (1-k) * p_xy.x + k; choice = 1; }
                    
                    let p_next = { x: nx + tx, y: ny + ty };
                    if (p_next.y < 0 || p_next.y > 1) continue;
                    
                    p_xy = applyRibbonTopology(p_next);
                    if (i > 20) attractorPoints2D[choice].push(p_xy);
                }
            } else { // 'wrap' mode
                for (let i = 0; i < NUM_POINTS; i++) {
                    let nx, ny, choice;
                    if (Math.random() < p1) { nx = p_xy.y; ny = k * p_xy.x; choice = 0; } 
                    else { nx = p_xy.y; ny = (1-k) * p_xy.x + k; choice = 1; }
                    p_xy = { x: nx, y: ny };
                    if (i > 20) attractorPoints2D[choice].push(p_xy);
                }
            }
            
            const colors = [0x76ff03, 0xff1744];
            attractorPoints2D.forEach((points, index) => {
                if (points.length === 0) return;
                const positions = new Float32Array(points.length * 3);
                points.forEach((p, i) => {
                    const p3d = mapToRibbon(p.x, p.y);
                    positions[i*3] = p3d.x; positions[i*3+1] = p3d.y; positions[i*3+2] = p3d.z;
                });
                const geom = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({ color: colors[index], size: 0.015, sizeAttenuation: true });
                const pointsObject = new THREE.Points(geom, mat);
                scene.add(pointsObject);
                pointsObjects.push(pointsObject);
            });
            updateVisibility();
        }
        
        function createOrUpdateWireframe() { /* ... Giữ nguyên ... */ }
        function updateVisibility() {
            const visibility = document.querySelector('input[name="visibility"]:checked').value;
            if (pointsObjects.length === 2) {
                pointsObjects[0].visible = (visibility === 'green' || visibility === 'both');
                pointsObjects[1].visible = (visibility === 'red' || visibility === 'both');
            }
        }
        
        function regenerate() {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const k = parseFloat(ui.kSlider.value);
            ribbonWidth = parseFloat(ui.pSlider.value);
            const tx = parseFloat(ui.txSlider.value);
            const ty = parseFloat(ui.tySlider.value);

            ui.kValue.textContent = k.toFixed(2);
            ui.pValue.textContent = ribbonWidth.toFixed(2);
            ui.txValue.textContent = tx.toFixed(2);
            ui.tyValue.textContent = ty.toFixed(2);
            
            // Hiện/ẩn các thanh trượt dịch chuyển
            ui.translationControls.style.display = (mode === 'glue') ? 'block' : 'none';

            if(mode === 'glue') {
                ui.title.textContent = 'Fractal "DÁN" Tôpô lên Dải băng Thắt nút';
                ui.explanation.innerHTML = `<p>Sử dụng phép <strong>"dán" tôpô</strong>. Dùng các thanh trượt dịch chuyển để đẩy fractal và quan sát nó được nối lại một cách liền lạc ở biên.</p>`;
            } else {
                ui.title.textContent = 'Fractal "BỌC" Tham số lên Dải băng Thắt nút';
                ui.explanation.innerHTML = `<p>Sử dụng phép <strong>"bọc" tham số</strong>. Attractor được tạo ra trong hình vuông 2D rồi "bọc" lên bề mặt. Chú ý các đường cắt gãy ở vị trí nối của dải băng.</p>`;
            }

            updateMathJax(k, tx, ty);
            createOrUpdateWireframe();
            generateFractalPoints(mode, k, tx, ty);
        }
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, ui.canvasContainer.clientWidth / ui.canvasContainer.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 5);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(ui.canvasContainer.clientWidth, ui.canvasContainer.clientHeight);
            ui.canvasContainer.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.9).position.set(5, 10, 7.5));
            scene.add(createLabeledAxes(3.5));
            
            ui.modeControls.forEach(radio => radio.addEventListener('change', regenerate));
            ui.visibilityControls.forEach(radio => radio.addEventListener('change', updateVisibility));
            ui.kSlider.addEventListener('input', () => { ui.kValue.textContent = ui.kSlider.value; regenerate(); });
            ui.pSlider.addEventListener('input', () => { ui.pValue.textContent = ui.pSlider.value; regenerate(); });
            ui.txSlider.addEventListener('input', () => { ui.txValue.textContent = ui.txSlider.value; regenerate(); });
            ui.tySlider.addEventListener('input', () => { ui.tyValue.textContent = ui.tySlider.value; regenerate(); });
            
            window.addEventListener('resize', () => { if(ui.canvasContainer) { camera.aspect = ui.canvasContainer.clientWidth / ui.canvasContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(ui.canvasContainer.clientWidth, ui.canvasContainer.clientHeight); } });
            regenerate();
            (function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); })();
        }

        createLabeledAxes = function(size) {
            const group = new THREE.Group();
            const axesHelper = new THREE.AxesHelper(size); group.add(axesHelper);
            const coneRadius = size*0.03; const coneHeight = size*0.1;
            const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const createLabel = (text, color, position) => {
                const canvas = document.createElement('canvas'); const context = canvas.getContext('2d');
                const canvasSize = 64; canvas.width = canvasSize; canvas.height = canvasSize;
                context.font = `Bold ${canvasSize/2}px Arial`; context.fillStyle = color;
                context.textAlign = 'center'; context.textBaseline = 'middle';
                context.fillText(text, canvasSize/2, canvasSize/2);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.4, 0.4, 1.0); sprite.position.copy(position); return sprite;
            };
            const arrowX = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color:0xff0000}));
            arrowX.position.set(size,0,0); arrowX.rotation.z = -Math.PI/2;
            group.add(arrowX, createLabel('X','#ff7777',new THREE.Vector3(size+coneHeight, 0.1, 0)));
            const arrowY = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color:0x00ff00}));
            arrowY.position.set(0,size,0);
            group.add(arrowY, createLabel('Y','#77ff77',new THREE.Vector3(0.1, size+coneHeight, 0)));
            const arrowZ = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color:0x0000ff}));
            arrowZ.position.set(0,0,size); arrowZ.rotation.x = Math.PI/2;
            group.add(arrowZ, createLabel('Z','#7777ff',new THREE.Vector3(0, 0.1, size+coneHeight)));
            group.add(createLabel('O','#ffffff',new THREE.Vector3(0.1,-0.1,0)));
            return group;
        };
        createOrUpdateWireframe = function() {
            if (ribbonMesh) { scene.remove(ribbonMesh); ribbonMesh.geometry.dispose(); ribbonMesh.material.dispose(); }
            const ribbonFunc = (t_param, v_param, target) => {
                 const t = 2*Math.PI*t_param; const v = (v_param-0.5)*ribbonWidth;
                 const frame = getFrenetFrame(t); const centerPoint = c(t);
                 target.copy(centerPoint).addScaledVector(frame.N, v);
            };
            const ribbonGeom = new ParametricGeometry(ribbonFunc, 256, 2);
            const ribbonMat = new THREE.MeshStandardMaterial({color:0x444444, wireframe:true, transparent:true, opacity:0.15, side:THREE.DoubleSide});
            ribbonMesh = new THREE.Mesh(ribbonGeom, ribbonMat);
            scene.add(ribbonMesh);
        };
        init();
    </script>
</body>
</html>